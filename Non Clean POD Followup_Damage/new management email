function draftNonCleanPODSummaryEmail() {
 // populateDetailsForBranch(); // Step 1: Run prerequisite
  runtest();

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ageSheet = ss.getSheetByName("Age_Bucket_Branch_Wise");
  const detailsSheet = ss.getSheetByName("details for branch");

  const emailTo = "naveen@lobb.in";
  const ccTo = "naveenkumar.m@lobb.com";
  const subject = "Summary Non-clean POD's as on 14-June-2025";

  // Step 2: Get pivot data
  const pivotData = ageSheet.getRange("A26:G47").getDisplayValues();

  // Step 3: Build formatted HTML table
  const htmlTable = buildPivotHtmlTable(pivotData);

  // Step 4: Filter data and find top transporter
  const allData = detailsSheet.getDataRange().getValues();
  const headers = allData[0];
  const filtered = allData.filter((r, i) => i > 0 && (r[7] === "Above 45 Days" || r[7] === "21-45 Days"));

  const transporterMap = {};
  filtered.forEach(row => {
    const transporter = row[5];
    const pending = parseFloat(row[8]) || 0;
    transporterMap[transporter] = (transporterMap[transporter] || 0) + pending;
  });

  const topTransporter = Object.entries(transporterMap).sort((a,b) => b[1] - a[1])[0] || ["N/A", 0];

  // Step 5: Create temp report
  const tempSpreadsheet = SpreadsheetApp.create("Temp_Report_NonCleanPOD_" + new Date().getTime());
  const tempSheet = tempSpreadsheet.getActiveSheet();
  tempSheet.getRange(1, 1, filtered.length + 1, headers.length).setValues([headers, ...filtered]);

  // Step 6: Add pivot sheet
  const pivotSheet = tempSpreadsheet.insertSheet("Pivot");
  const dataRange = tempSheet.getDataRange();
  const pivotStartCell = pivotSheet.getRange('A1');
  const pivotTable = pivotStartCell.createPivotTable(dataRange);

  pivotTable.addRowGroup(2); // Column C (Branch Name)
  pivotTable.addColumnGroup(7); // Column H (Bucket)
  pivotTable.addPivotValue(1, SpreadsheetApp.PivotTableSummarizeFunction.COUNTA); // Count TXN Num
  pivotTable.addPivotValue(8, SpreadsheetApp.PivotTableSummarizeFunction.SUM); // Sum Pending Amount

  // Step 7: Export to XLSX
  const fileId = tempSpreadsheet.getId();
  const blob = exportSpreadsheetToXLSX(fileId, "Non_Clean_POD_Report.xlsx");

  // Step 8: Compose email body
  const body = `
    <p>Dear Sir,</p>
    <p>Please find the below Non clean POD trip and revenue details.</p>
    ${htmlTable}
    <p><strong>Insight:</strong> The transporter with the highest pending amount is <b>${topTransporter[0]}</b> with Rs. ${topTransporter[1].toLocaleString()} pending.</p>
    <p>Regards,<br>Your Automation Bot</p>
  `;

  // Step 9: Create draft
  GmailApp.createDraft(emailTo, subject, '', {
    htmlBody: body,
    cc: ccTo,
    attachments: [blob]
  });

  // Step 10: Delete temp sheet
  DriveApp.getFileById(fileId).setTrashed(true);
  Logger.log("Draft created successfully with attachment.");
}


// -----------------------------------
// Helper 1: Build pivot HTML table with unified color scales
// -----------------------------------
function buildPivotHtmlTable(pivotData) {
  const group1Cols = [1, 3, 5]; // B, D, F → No. of Trips
  const group2Cols = [2, 4, 6]; // C, E, G → Pending Amount

  const getValues = (cols) => {
    return pivotData.slice(4, -1).flatMap(row =>
      cols.map(c => parseFloat(row[c].replace(/[^0-9.-]/g, ''))).filter(v => !isNaN(v))
    );
  };

  const group1Values = getValues(group1Cols);
  const group2Values = getValues(group2Cols);
  const group1Min = Math.min(...group1Values);
  const group1Max = Math.max(...group1Values);
  const group2Min = Math.min(...group2Values);
  const group2Max = Math.max(...group2Values);

  const colorScaleGroup1 = { light: { r: 255, g: 242, b: 204 }, dark: { r: 255, g: 217, b: 102 } }; // Yellow
  const colorScaleGroup2 = { light: { r: 221, g: 235, b: 247 }, dark: { r: 0, g: 112, b: 192 } };   // Blue

  function getColor(value, min, max, scale) {
    if (min === max) return `rgb(${scale.dark.r},${scale.dark.g},${scale.dark.b})`;
    let ratio = (value - min) / (max - min);
    const r = Math.round(scale.light.r + ratio * (scale.dark.r - scale.light.r));
    const g = Math.round(scale.light.g + ratio * (scale.dark.g - scale.light.g));
    const b = Math.round(scale.light.b + ratio * (scale.dark.b - scale.light.b));
    return `rgb(${r},${g},${b})`;
  }

  let html = '<table border="1" style="border-collapse:collapse; font-family: Arial;">';
  pivotData.forEach((row, rIdx) => {
    html += "<tr>";
    row.forEach((cell, cIdx) => {
      let style = 'padding:4px;';
      if (rIdx >= 4 && rIdx < pivotData.length - 1) {
        let val = parseFloat(cell.toString().replace(/[^0-9.-]/g, ''));
        if (!isNaN(val)) {
          if (group1Cols.includes(cIdx)) {
            style += `background-color:${getColor(val, group1Min, group1Max, colorScaleGroup1)};`;
          } else if (group2Cols.includes(cIdx)) {
            style += `background-color:${getColor(val, group2Min, group2Max, colorScaleGroup2)};`;
          }
        }
      }
      html += `<td style="${style}">${cell}</td>`;
    });
    html += "</tr>";
  });
  html += "</table>";
  return html;
}

// -----------------------------------
// Helper 2: Export spreadsheet to XLSX
// -----------------------------------
function exportSpreadsheetToXLSX(fileId, exportName) {
  const url = `https://docs.google.com/feeds/download/spreadsheets/Export?key=${fileId}&exportFormat=xlsx`;
  const token = ScriptApp.getOAuthToken();
  const response = UrlFetchApp.fetch(url, {
    headers: {
      'Authorization': 'Bearer ' + token
    },
    muteHttpExceptions: true,
  });
  return response.getBlob().setName(exportName);
}
